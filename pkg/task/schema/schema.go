// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package schema

import "encoding/json"
import "fmt"
import yaml "gopkg.in/yaml.v3"

type Task struct {
	// List of actions that modify a repository.
	Actions []TaskActionsElem `json:"actions,omitempty" yaml:"actions,omitempty" mapstructure:"actions,omitempty"`

	// A list of usernames to set as assignees of a pull request.
	Assignees []string `json:"assignees,omitempty" yaml:"assignees,omitempty" mapstructure:"assignees,omitempty"`

	// Merge a pull request automatically if all checks have passed and all approvals
	// have been given.
	AutoMerge bool `json:"autoMerge,omitempty" yaml:"autoMerge,omitempty" mapstructure:"autoMerge,omitempty"`

	// If set, automatically merge the pull request after it has been open for the
	// specified amount of time. Only applied if `autoMerge` is `true`. The value is a
	// Go duration, like 5m or 1h.
	AutoMergeAfter string `json:"autoMergeAfter,omitempty" yaml:"autoMergeAfter,omitempty" mapstructure:"autoMergeAfter,omitempty"`

	// If set, used as th name of the branch to commit changes to. Defaults to an
	// auto-generated name if not set.
	BranchName string `json:"branchName,omitempty" yaml:"branchName,omitempty" mapstructure:"branchName,omitempty"`

	// Number of pull requests to create or merge (combined) in one run. Useful to
	// reduce strain on a system caused by, for example, many CI/CD jobs created at
	// the same time.
	ChangeLimit int `json:"changeLimit,omitempty" yaml:"changeLimit,omitempty" mapstructure:"changeLimit,omitempty"`

	// If set, used as the message when changes get committed. Defaults to an
	// auto-generated message if not set.
	CommitMessage string `json:"commitMessage,omitempty" yaml:"commitMessage,omitempty" mapstructure:"commitMessage,omitempty"`

	// Create pull requests only. Don't attempt to update a pull request on a
	// subsequent run.
	CreateOnly bool `json:"createOnly,omitempty" yaml:"createOnly,omitempty" mapstructure:"createOnly,omitempty"`

	// Disable the task temporarily.
	Disabled *bool `json:"disabled,omitempty" yaml:"disabled,omitempty" mapstructure:"disabled,omitempty"`

	// Filters allow targeting a specific repositories.
	Filters []TaskFiltersElem `json:"filters,omitempty" yaml:"filters,omitempty" mapstructure:"filters,omitempty"`

	// If `true`, keep the branch after a pull request has been merged.
	KeepBranchAfterMerge bool `json:"keepBranchAfterMerge,omitempty" yaml:"keepBranchAfterMerge,omitempty" mapstructure:"keepBranchAfterMerge,omitempty"`

	// List of labels to attach to a pull request.
	Labels []string `json:"labels,omitempty" yaml:"labels,omitempty" mapstructure:"labels,omitempty"`

	// The number of pull requests that can be open at the same time. 0 disables the
	// feature.
	MaxOpenPRs int `json:"maxOpenPRs,omitempty" yaml:"maxOpenPRs,omitempty" mapstructure:"maxOpenPRs,omitempty"`

	// If `true`, no new pull request is being created if a previous pull request has
	// been merged for this task.
	MergeOnce bool `json:"mergeOnce,omitempty" yaml:"mergeOnce,omitempty" mapstructure:"mergeOnce,omitempty"`

	// The name of the task. Used as an identifier.
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// Plugins corresponds to the JSON schema field "plugins".
	Plugins []TaskPluginsElem `json:"plugins,omitempty" yaml:"plugins,omitempty" mapstructure:"plugins,omitempty"`

	// If set, used as the body of the pull request.
	PrBody string `json:"prBody,omitempty" yaml:"prBody,omitempty" mapstructure:"prBody,omitempty"`

	// If set, used as the title of the pull request.
	PrTitle string `json:"prTitle,omitempty" yaml:"prTitle,omitempty" mapstructure:"prTitle,omitempty"`

	// A list of usernames to set as reviewers of the pull request.
	Reviewers []string `json:"reviewers,omitempty" yaml:"reviewers,omitempty" mapstructure:"reviewers,omitempty"`
}

type TaskActionsElem struct {
	// Identifier of the action.
	Action string `json:"action" yaml:"action" mapstructure:"action"`

	// Key/value pairs passed as parameters to the action.
	Params TaskActionsElemParams `json:"params,omitempty" yaml:"params,omitempty" mapstructure:"params,omitempty"`
}

// Key/value pairs passed as parameters to the action.
type TaskActionsElemParams map[string]interface{}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TaskActionsElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["action"]; raw != nil && !ok {
		return fmt.Errorf("field action in TaskActionsElem: required")
	}
	type Plain TaskActionsElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = TaskActionsElem(plain)
	return nil
}

// UnmarshalYAML implements yaml.Unmarshaler.
func (j *TaskActionsElem) UnmarshalYAML(value *yaml.Node) error {
	var raw map[string]interface{}
	if err := value.Decode(&raw); err != nil {
		return err
	}
	if _, ok := raw["action"]; raw != nil && !ok {
		return fmt.Errorf("field action in TaskActionsElem: required")
	}
	type Plain TaskActionsElem
	var plain Plain
	if err := value.Decode(&plain); err != nil {
		return err
	}
	*j = TaskActionsElem(plain)
	return nil
}

type TaskFiltersElem struct {
	// Identifier of the filter.
	Filter string `json:"filter" yaml:"filter" mapstructure:"filter"`

	// Key/value pairs passed as parameters to the filter.
	Params TaskFiltersElemParams `json:"params,omitempty" yaml:"params,omitempty" mapstructure:"params,omitempty"`

	// Reverse the result of the filter, i.e. negate it.
	Reverse bool `json:"reverse,omitempty" yaml:"reverse,omitempty" mapstructure:"reverse,omitempty"`
}

// Key/value pairs passed as parameters to the filter.
type TaskFiltersElemParams map[string]interface{}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TaskFiltersElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["filter"]; raw != nil && !ok {
		return fmt.Errorf("field filter in TaskFiltersElem: required")
	}
	type Plain TaskFiltersElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["reverse"]; !ok || v == nil {
		plain.Reverse = false
	}
	*j = TaskFiltersElem(plain)
	return nil
}

// UnmarshalYAML implements yaml.Unmarshaler.
func (j *TaskFiltersElem) UnmarshalYAML(value *yaml.Node) error {
	var raw map[string]interface{}
	if err := value.Decode(&raw); err != nil {
		return err
	}
	if _, ok := raw["filter"]; raw != nil && !ok {
		return fmt.Errorf("field filter in TaskFiltersElem: required")
	}
	type Plain TaskFiltersElem
	var plain Plain
	if err := value.Decode(&plain); err != nil {
		return err
	}
	if v, ok := raw["reverse"]; !ok || v == nil {
		plain.Reverse = false
	}
	*j = TaskFiltersElem(plain)
	return nil
}

type TaskPluginsElem struct {
	// Key/value pairs that hold additional configuration for the plugin. Sent to the
	// plugin once on startup.
	Configuration TaskPluginsElemConfiguration `json:"configuration,omitempty" yaml:"configuration,omitempty" mapstructure:"configuration,omitempty"`

	// Path corresponds to the JSON schema field "path".
	Path string `json:"path" yaml:"path" mapstructure:"path"`
}

// Key/value pairs that hold additional configuration for the plugin. Sent to the
// plugin once on startup.
type TaskPluginsElemConfiguration map[string]string

// UnmarshalJSON implements json.Unmarshaler.
func (j *TaskPluginsElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["path"]; raw != nil && !ok {
		return fmt.Errorf("field path in TaskPluginsElem: required")
	}
	type Plain TaskPluginsElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = TaskPluginsElem(plain)
	return nil
}

// UnmarshalYAML implements yaml.Unmarshaler.
func (j *TaskPluginsElem) UnmarshalYAML(value *yaml.Node) error {
	var raw map[string]interface{}
	if err := value.Decode(&raw); err != nil {
		return err
	}
	if _, ok := raw["path"]; raw != nil && !ok {
		return fmt.Errorf("field path in TaskPluginsElem: required")
	}
	type Plain TaskPluginsElem
	var plain Plain
	if err := value.Decode(&plain); err != nil {
		return err
	}
	*j = TaskPluginsElem(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Task) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in Task: required")
	}
	type Plain Task
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["autoMerge"]; !ok || v == nil {
		plain.AutoMerge = false
	}
	if v, ok := raw["autoMergeAfter"]; !ok || v == nil {
		plain.AutoMergeAfter = ""
	}
	if v, ok := raw["branchName"]; !ok || v == nil {
		plain.BranchName = ""
	}
	if v, ok := raw["changeLimit"]; !ok || v == nil {
		plain.ChangeLimit = 0.0
	}
	if v, ok := raw["commitMessage"]; !ok || v == nil {
		plain.CommitMessage = ""
	}
	if v, ok := raw["createOnly"]; !ok || v == nil {
		plain.CreateOnly = false
	}
	if v, ok := raw["keepBranchAfterMerge"]; !ok || v == nil {
		plain.KeepBranchAfterMerge = false
	}
	if v, ok := raw["maxOpenPRs"]; !ok || v == nil {
		plain.MaxOpenPRs = 0.0
	}
	if v, ok := raw["mergeOnce"]; !ok || v == nil {
		plain.MergeOnce = false
	}
	if v, ok := raw["prBody"]; !ok || v == nil {
		plain.PrBody = ""
	}
	if v, ok := raw["prTitle"]; !ok || v == nil {
		plain.PrTitle = ""
	}
	*j = Task(plain)
	return nil
}

// UnmarshalYAML implements yaml.Unmarshaler.
func (j *Task) UnmarshalYAML(value *yaml.Node) error {
	var raw map[string]interface{}
	if err := value.Decode(&raw); err != nil {
		return err
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in Task: required")
	}
	type Plain Task
	var plain Plain
	if err := value.Decode(&plain); err != nil {
		return err
	}
	if v, ok := raw["autoMerge"]; !ok || v == nil {
		plain.AutoMerge = false
	}
	if v, ok := raw["autoMergeAfter"]; !ok || v == nil {
		plain.AutoMergeAfter = ""
	}
	if v, ok := raw["branchName"]; !ok || v == nil {
		plain.BranchName = ""
	}
	if v, ok := raw["changeLimit"]; !ok || v == nil {
		plain.ChangeLimit = 0.0
	}
	if v, ok := raw["commitMessage"]; !ok || v == nil {
		plain.CommitMessage = ""
	}
	if v, ok := raw["createOnly"]; !ok || v == nil {
		plain.CreateOnly = false
	}
	if v, ok := raw["keepBranchAfterMerge"]; !ok || v == nil {
		plain.KeepBranchAfterMerge = false
	}
	if v, ok := raw["maxOpenPRs"]; !ok || v == nil {
		plain.MaxOpenPRs = 0.0
	}
	if v, ok := raw["mergeOnce"]; !ok || v == nil {
		plain.MergeOnce = false
	}
	if v, ok := raw["prBody"]; !ok || v == nil {
		plain.PrBody = ""
	}
	if v, ok := raw["prTitle"]; !ok || v == nil {
		plain.PrTitle = ""
	}
	*j = Task(plain)
	return nil
}
